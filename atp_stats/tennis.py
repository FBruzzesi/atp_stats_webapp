from datetime import date
from functools import reduce
from operator import and_
from typing import Dict, List, Optional, Tuple, Union

import numpy as np
import plotly.express as px
import plotly.figure_factory as ff
import plotly.graph_objects as go
import polars as pl
from compclasses import compclass
from plotly.subplots import make_subplots

from .utils import proportion_confint

surface_colors = {
    "Clay": "firebrick",
    "Grass": "seagreen",
    "Hard": "midnightblue",
    "Carpet": "limegreen",
}


class Player:
    """
    Player instance generated by parsing matches and players dataframe,
    filtering on the player name
    """

    def __init__(self, name: str, matches: pl.DataFrame, info: Dict):
        """
        Arguments:
            name: name of the player
            matches: dataframe of player matches
            info: dict containing player info as in
                https://github.com/JeffSackmann/tennis_atp/blob/master/atp_players.csv
        """

        self.name = name
        self.matches = matches

        self.ranks = (
            self.matches.groupby("year")
            .agg([pl.col("rank").min().cast(pl.UInt16)])
            .sort("year")
        )

        self.info = {
            **info,
            **{
                # "age": round((date.today() - info["birthdate"]).days / 365.25, 2),
                "best_rank": self.ranks.select(pl.min("rank")).to_dicts()[0]["rank"],
                # "birthdate": info["birthdate"].strftime("%d %b %Y"),
            },
        }

        # called to create attributes for all player matches, without filters
        self.filter()

    @classmethod
    def from_raw_dataframes(
        cls, name: str, raw_matches: pl.DataFrame, raw_players: pl.DataFrame
    ) -> "Player":
        """
        Initializes Player class from raw dataframes with *all* players matches
        and full players list.
        """

        info = raw_players.filter(pl.col("player_name") == name).to_dicts()[0]

        matches = raw_matches.filter(pl.col("id") == info["id"]).sort(
            ["tourney_date", "match_num"]
        )
        return Player(name, matches, info)

    def __repr__(self):

        return f"Player {self.name} with {self.matches.shape[0]} matches played"

    def filter(
        self,
        time_start: Optional[date] = date(1970, 1, 1),
        time_end: Optional[date] = date(2999, 12, 31),
        surfaces: Optional[List[str]] = None,
        tourney_levels: Optional[List[str]] = None,
        tournaments: Optional[List[str]] = None,
        opponents: Optional[List[str]] = None,
        rounds: Optional[List[str]] = None,
        opponent_ranks: Optional[int] = None,
    ):
        """
        Filters matches and ranks based on various conditions and at the same time
        it generates dataframes containing various statistics (by year, surface, opponent)

        Arguments:
            time_start: starting period of interest
            time_end: ending period of interest
            surfaces: list of surfaces to keep
            tourney_levels list of tourney levels to keep
            tournaments: list of tournaments to keep
            opponents: list of opponents to keep
            rounds: list of round levels to keep
            opponent_ranks: max opponent rank to keep
        """
        filters = {
            "time_start": time_start,
            "time_end": time_end,
            "surface": surfaces,
            "tourney_level": tourney_levels,
            "tourney_name": tournaments,
            "opponent_name": opponents,
            "round": rounds,
            "opponent_rank": opponent_ranks,
        }

        self.selected_matches = self.filter_matches(self.matches, filters)
        self.n_matches = self.selected_matches.shape[0]
        self.selected_ranks = self.filter_ranks(self.selected_matches, self.ranks)

        self.perc_overall = self.get_overall_stats(
            self.selected_matches, self.success_cols, self.total_cols
        )

        self.stats_by_year = self.get_yearly_stats(self.selected_matches)
        self.lower_df, self.upper_df = self.get_confint(
            self.stats_by_year, self.success_cols, self.total_cols
        )
        self.surface_wl = self.get_surface_winloss(self.selected_matches)
        self.h2h = self.get_h2h(self.selected_matches)

        return self

    @staticmethod
    def filter_matches(matches: pl.DataFrame, filters: Dict) -> pl.DataFrame:
        """
        Subsets all matches based on filters condition
        """

        time_start = pl.col("tourney_date") >= filters["time_start"]  # default 1970-01-01
        time_end = pl.col("tourney_date") <= filters["time_end"]  # default 2999-12-31

        conditions = [time_start, time_end]

        for key, value in filters.items():
            if (key not in ["time_start", "time_end"]) and (value):

                m = (
                    (pl.col("opponent_rank") < value)
                    if key == "opponent_rank"
                    else (pl.col(key).is_in(value))
                )

                conditions.append(m)

        return matches.filter(reduce(and_, conditions))

    @staticmethod
    def filter_ranks(selected_matches: pl.DataFrame, ranks: pl.DataFrame) -> pl.DataFrame:
        """
        Generate time series of player rank and rank points
        """
        selected_ranks = (
            selected_matches.groupby("year")
            .agg(
                pl.col("winner")
                .filter(pl.col("round") == "F")
                .sum()
                .fill_null(0)
                .alias("tourney_won")
            )
            .join(ranks, on="year")
            .select(["year", "rank", "tourney_won"])
        )
        return selected_ranks

    @staticmethod
    def get_overall_stats(
        selected_matches: pl.DataFrame, success_cols: List[str], total_cols: List[str]
    ) -> pl.DataFrame:
        """Stats not stratifies by any other column"""

        perc_overall = selected_matches.select(
            [(pl.mean("winner") * 100).round(2).alias("win_rate")]
            + [
                (pl.sum(s) / pl.sum(t) * 100).round(2).alias(f"perc_{s}")
                for s, t in zip(success_cols, total_cols)
            ]
        )
        return perc_overall

    @staticmethod
    def _aggregate_stats(
        dframe: pl.DataFrame, level: Union[str, List[str]]
    ) -> pl.DataFrame:
        """Sum by level and generates percentage columns on subset"""

        cols_to_sum = [
            "ace",
            "df",
            "svpt",
            "1stIn",
            "1stWon",
            "2ndIn",
            "2ndWon",
            "returnWon",
            "returnPlayed",
            "bpConverted",
            "bpTotal",
            "bpSaved",
            "bpFaced",
            "tbPlayed",
            "tbWon",
            "deciderPlayed",
            "deciderWon",
        ]

        agg_dframe = (
            dframe.groupby(level)
            .agg(
                [
                    pl.count("winner").alias("matches_played"),
                    pl.sum("winner").alias("matches_won"),
                ]
                + [pl.sum(c) for c in cols_to_sum]
            )
            .with_columns(
                [
                    (pl.col("matches_played") - pl.col("matches_won")).alias(
                        "matches_lost"
                    ),
                    (pl.col("matches_won") / pl.col("matches_played")).alias("win_rate"),
                    (pl.col("ace") / pl.col("svpt")).alias("perc_ace"),
                    (pl.col("df") / pl.col("svpt")).alias("perc_df"),
                    (pl.col("1stIn") / pl.col("svpt")).alias("perc_1stIn"),
                    (pl.col("1stWon") / pl.col("1stIn")).alias("perc_1stWon"),
                    (pl.col("2ndWon") / pl.col("2ndIn")).alias("perc_2ndWon"),
                    (pl.col("returnWon") / pl.col("returnPlayed")).alias(
                        "perc_returnWon"
                    ),
                    (pl.col("bpConverted") / pl.col("bpTotal")).alias("perc_bpConverted"),
                    (pl.col("bpSaved") / pl.col("bpFaced")).alias("perc_bpSaved"),
                    (pl.col("tbPlayed") - pl.col("tbWon")).alias("tbLost"),
                    (pl.col("tbWon") / pl.col("tbPlayed")).alias("perc_tbWon"),
                    (pl.col("deciderPlayed") - pl.col("deciderWon")).alias("deciderLost"),
                    (pl.col("deciderWon") / pl.col("deciderPlayed")).alias(
                        "perc_deciderWon"
                    ),
                ]
            )
        )
        return agg_dframe

    @staticmethod
    def get_yearly_stats(selected_matches: pl.DataFrame) -> pl.DataFrame:
        """
        Calculate statistics aggregated by year
        """

        stats_by_year = Player._aggregate_stats(selected_matches, level="year").sort(
            "year"
        )

        return stats_by_year

    def get_confint(
        self, dframe: pl.DataFrame, success_cols: List[str], total_cols: List[str]
    ) -> Tuple[pl.DataFrame, pl.DataFrame]:
        """
        Computes lower and upper bound estimate of variables
        Successes are obtained from the columns in success_cols
        Totals are obtained from the columns in total_cols

        If len(success_cols) != len(total_cols) the code will break
        """

        count = dframe.select(
            pl.col(c).alias(str(i)) for i, c in enumerate(success_cols)
        ).to_numpy()

        nobs = dframe.select(
            pl.col(c).alias(str(i)) for i, c in enumerate(total_cols)
        ).to_numpy()

        ci_low, ci_upp = proportion_confint(count, nobs)

        # TODO: Should we add the year or should we trust the ordering?
        lower_df = pl.DataFrame(ci_low, schema=[f"lower_{c}" for c in self.success_cols])
        upper_df = pl.DataFrame(ci_upp, schema=[f"upper_{c}" for c in self.success_cols])

        return lower_df, upper_df

    @staticmethod
    def get_surface_winloss(selected_matches: pl.DataFrame) -> pl.DataFrame:
        """
        Calculate win/loss count by surface
        """
        return selected_matches.groupby(["surface", "result"]).agg(
            pl.count("id").alias("cnt")
        )

    @staticmethod
    def get_h2h(selected_matches: pl.DataFrame) -> pl.DataFrame:
        """Calculate win rate by opponent"""
        h2h = (
            Player._aggregate_stats(selected_matches, level="opponent_name")
            .sort("matches_played", reverse=True)
            .head(15)  # 15 most frequent opponents
        )

        return h2h

    @property
    def success_cols(self) -> List[str]:
        # TODO: move outside
        return [
            "ace",
            "df",
            "1stIn",
            "1stWon",
            "2ndWon",
            "returnWon",
            "bpConverted",
            "bpSaved",
            "tbWon",
            "deciderWon",
        ]

    @property
    def total_cols(self) -> List[str]:
        # TODO: move outside
        return [
            "svpt",
            "svpt",
            "svpt",
            "1stIn",
            "2ndIn",
            "returnPlayed",
            "bpTotal",
            "bpFaced",
            "tbPlayed",
            "deciderPlayed",
        ]


delegates = {
    "player": (
        "selected_matches",
        "n_matches",
        "selected_ranks",
        "stats_by_year",
        "lower_df",
        "upper_df",
        "surface_wl",
        "h2h",
    ),
}


@compclass(delegates=delegates)
class Renderer:
    """
    Helper class to plot player stats with plotly

    # WIP: many functionalities are currently repeated
    """

    def __init__(self, player: Player):

        self.player = player

        self._colors = [
            "rgb(33,113,181)",
            "rgb(217,71,1)",
            "rgb(81, 178, 124)",
            "rgb(235, 127, 134)",
        ] * 2

    def plot_summary(self) -> Tuple[go.Figure, go.Figure]:
        """
        Generates two figures:

        - fig1: best rank and number of titles by year
        - fig2: win rate and number of matches player by year
        """
        fig1 = make_subplots(
            specs=[[{"secondary_y": True}]],
        )

        # Add Rank over time
        x1, y1, y2 = (
            self.selected_ranks.select(["year", "rank", "tourney_won"]).to_numpy().T
        )

        fig1.add_trace(
            go.Scatter(
                x=x1,
                y=y1,
                name="Rank",
                marker={"color": "goldenrod"},
                mode="lines+text",
                text=y1,
                textposition="bottom center",
                textfont_size=8,
                opacity=0.8,
            ),
            secondary_y=False,
            row=1,
            col=1,
        )

        fig1.add_trace(
            go.Bar(
                x=x1,
                y=y2,
                name="Tournaments Won",
                marker={"color": "midnightblue"},
                text=y2,
                textposition="inside",
                textfont_size=8,
                opacity=0.8,
            ),
            secondary_y=True,
            row=1,
            col=1,
        )

        fig1.update_layout(
            height=500,
            legend={
                "font": {"size": 10},
                "orientation": "h",
                "yanchor": "bottom",
                "y": 1.05,
                "xanchor": "right",
                "x": 1,
            },
            title_font_size=18,
            title={
                "text": "Best Rank and Titles by Year",
                "x": 0.5,
                "xanchor": "center",
                "y": 0.9,
                "yanchor": "top",
            },
            xaxis={"title": "Year-Month"},
            yaxis={"title": "Best Rank", "range": [np.max(y1) + 10, -2]},
            yaxis2={"title": "Tournaments Won", "range": [0, np.max(y2) * 1.1]},
        )

        fig2 = make_subplots(
            specs=[[{"secondary_y": True}]],
        )

        # Add Winrate over time

        x2, b1, b2, wr = (
            self.stats_by_year.select(
                ["year", "matches_won", "matches_lost", 100 * pl.col("win_rate")]
            )
            .to_numpy()
            .T
        )

        fig2.add_trace(
            go.Bar(
                x=x2,
                y=b1,
                name="Matches Won",
                marker={"color": "seagreen"},
                text=b1,
                textposition="inside",
                textfont_size=8,
                opacity=0.8,
            ),
            secondary_y=False,
            row=1,
            col=1,
        )
        fig2.add_trace(
            go.Bar(
                x=x2,
                y=b2,
                name="Matches Lost",
                marker={"color": "indianred"},
                text=b2,
                textposition="inside",
                textfont_size=8,
                opacity=0.8,
            ),
            secondary_y=False,
            row=1,
            col=1,
        )

        fig2.add_trace(
            go.Scatter(
                x=x2,
                y=wr,
                name="Win Rate",
                line={"color": "midnightblue", "width": 2},
                mode="lines+text",
                text=[str(p) + "%" for p in np.round(wr, 2)],
                textposition="top center",
                textfont_size=8,
            ),
            secondary_y=True,
            row=1,
            col=1,
        )

        fig2.update_layout(
            height=500,
            legend={
                "font": {"size": 10},
                "orientation": "h",
                "traceorder": "normal",
                "yanchor": "bottom",
                "y": 1.025,
                "xanchor": "right",
                "x": 1,
            },
            title_font_size=18,
            title={
                "text": "Win Rate and Played Matches by Year",
                "x": 0.5,
                "xanchor": "center",
                "y": 0.9,
                "yanchor": "top",
            },
            barmode="stack",
            xaxis={"title": "Year-Month"},
            yaxis1={
                "range": [
                    0,
                    int(self.stats_by_year.select(pl.max("matches_played")).to_numpy())
                    + 15,
                ],
                "title": "Number of Matches",
            },
            yaxis2={"range": [0, 105], "title": "Win Rate (%)"},
        )

        return fig1, fig2

    def plot_surface_wl(
        self, surface_colors: Dict[str, str] = surface_colors
    ) -> go.Figure:
        """
        Plots number of wins-losses by surface type
        """
        fig = px.sunburst(
            data_frame=self.surface_wl.to_pandas(),
            path=["surface", "result"],
            values="cnt",
            names="cnt",
            hover_data=["cnt"],
        )

        fig.data[0].marker.colors = [
            surface_colors[s.split("/")[0]] for s in fig.data[0].ids
        ]

        fig.update_layout(
            title={
                "text": "Win-Loss by Surface",
                "y": 1,
                "x": 0.5,
                "xanchor": "center",
                "yanchor": "top",
            },
        )

        return fig

    def plot_serve_return_stats(self, columns: List[str]) -> go.Figure:
        """
        Plots statistics from a list of columns (Typically serve and/or return stats)
        LHS of figure has trend year over year with confidence intervals
        RHS of figure shows distribution from single matches (hist+kde)
        """

        y_dist = (
            100
            * self.selected_matches.select([f"perc_{c}" for c in columns]).to_numpy().T
        )
        x, *y_stats = (
            self.stats_by_year.select(
                ["year"] + [(pl.col(f"perc_{c}") * 100) for c in columns]
            )
            .to_numpy()
            .T
        )
        y_lower = 100 * self.lower_df.select([f"lower_{c}" for c in columns]).to_numpy().T
        y_upper = 100 * self.upper_df.select([f"upper_{c}" for c in columns]).to_numpy().T

        colors = self._colors

        n_cols, n_rows = 2, len(columns)

        subplot_titles = [
            [
                f"Percentage {c[0].upper() + c[1:]} and 95% CI by year",
                f"Single Match Perc. {c[0].upper() + c[1:]} Distribution",
            ]
            for c in columns
        ]

        fig = make_subplots(
            cols=n_cols,
            rows=n_rows,
            specs=[[{}, {}]] * n_rows,
            shared_xaxes=False,
            vertical_spacing=0.05,
            horizontal_spacing=0.05,
            subplot_titles=sum(subplot_titles, []),
            column_widths=[0.7, 0.3],
        )

        for i, col in enumerate(columns):

            # Upper bound
            fig.add_trace(
                go.Scatter(
                    x=x,
                    y=y_upper[i],
                    name=f"{col} upper bound",
                    fill=None,
                    mode="lines",
                    line=dict(color="darksalmon", width=1),
                ),
                row=i + 1,
                col=1,
            )

            # Lower Bound
            fig.add_trace(
                go.Scatter(
                    x=x,
                    y=y_lower[i],
                    name=f"{col} lower bound",
                    fill="tonexty",
                    mode="lines",
                    line=dict(color="darksalmon", width=1),
                ),
                row=i + 1,
                col=1,
            )

            # Realized
            fig.add_trace(
                go.Scatter(
                    x=x,
                    y=y_stats[i],
                    textposition="top center",
                    name=col,
                    mode="lines+markers",
                    connectgaps=True,
                    marker={"color": colors[i]},
                ),
                row=i + 1,
                col=1,
            )

            # Distribution
            c_dist = y_dist[i]
            hist, kde = ff.create_distplot(
                [c_dist],
                bin_size=(c_dist.max() - c_dist.min()) / 50,
                group_labels=[col],
                show_rug=False,
                colors=[colors[i]],
                histnorm="probability",
            )["data"]

            fig.add_trace(hist, row=i + 1, col=2)
            fig.add_trace(kde, row=i + 1, col=2)

        # Layout
        fig.update_layout(
            {
                "showlegend": False,
                "xaxis": {"title": "Year"},
                "yaxis": {"title": "Percentage"},
                **{f"xaxis{2*i+1}": {"title": "Year"} for i in range(1, n_rows + 1)},
                **{f"xaxis{2*i}": {"title": "Percentage"} for i in range(1, n_rows + 1)},
                **{
                    f"yaxis{2*i+1}": {"title": "Percentage"} for i in range(1, n_rows + 1)
                },
                **{
                    f"yaxis{2*i}": {"title": "Frequency", "side": "right"}
                    for i in range(1, n_rows + 1)
                },
            }
        )

        return fig

    def plot_boxplot_distribution(self, columns: List[str]) -> go.Figure:
        """
        Plots boxplot distribution from single matches of list of columns
        """
        yrs, *y_dist = (
            self.selected_matches.select(
                ["year"] + [(pl.col(f"perc_{c}") * 100) for c in columns]
            )
            .to_numpy()
            .T
        )

        colors = self._colors

        n_cols, n_rows = 2, len(columns)
        subplot_titles = [[f"{c} Boxplot", f"{c} Distplot"] for c in columns]

        fig = make_subplots(
            cols=n_cols,
            rows=n_rows,
            specs=[[{}, {}]] * n_rows,
            shared_xaxes=True,
            shared_yaxes=True,
            vertical_spacing=0.08,
            horizontal_spacing=0.02,
            subplot_titles=sum(subplot_titles, []),
            column_widths=[0.8, 0.2],
        )

        for i, col in enumerate(columns):

            fig.add_trace(
                go.Box(x=yrs, y=y_dist[i], marker_color=colors[i]),
                row=i + 1,
                col=1,
            )

            hist, kde = ff.create_distplot(
                [y_dist[i]],
                bin_size=1.5,
                group_labels=[col],
                show_rug=False,
                colors=[colors[i]],
                histnorm="probability",
            )["data"]

            hist_ = go.Histogram(
                y=hist["x"],
                histnorm="probability",
                ybins={
                    "start": hist["xbins"]["start"],
                    "end": hist["xbins"]["end"],
                    "size": hist["xbins"]["size"],
                },
                opacity=0.7,
                marker_color=colors[i],
            )

            kde_ = go.Scatter(x=kde["y"], y=kde["x"], marker_color=colors[i])

            fig.add_trace(hist_, row=i + 1, col=2)
            fig.add_trace(kde_, row=i + 1, col=2)

        # Layout
        fig.update_layout(
            {
                "showlegend": False,
                f"xaxis{n_rows*n_cols-1}": {"title": "Year"},
                f"xaxis{n_rows*n_cols}": {"title": "Frequency"},
                **{
                    f"yaxis{2*r-1}": {"title": "Percentage"} for r in range(1, n_rows + 1)
                },
            }
        )

        return fig

    def plot_under_pressure(self, columns: List[str]) -> go.Figure:
        """
        Plots trend year over year with confidence intervals of list of columns
        """
        x, *y_stats = (
            self.stats_by_year.select(
                ["year"] + [(pl.col(f"perc_{c}") * 100) for c in columns]
            )
            .to_numpy()
            .T
        )
        y_lower = 100 * self.lower_df.select([f"lower_{c}" for c in columns]).to_numpy().T
        y_upper = 100 * self.upper_df.select([f"upper_{c}" for c in columns]).to_numpy().T

        colors = self._colors

        n_cols, n_rows = 1, len(columns)
        subplot_titles = [
            f"Percentage {c[0].upper() + c[1:]} and 95% CI by year" for c in columns
        ]

        fig = make_subplots(
            cols=n_cols,
            rows=n_rows,
            specs=[[{}]] * n_rows,
            shared_xaxes=True,
            vertical_spacing=0.1,
            horizontal_spacing=0.05,
            subplot_titles=subplot_titles,
        )

        for i, col in enumerate(columns):

            # Upper bound
            fig.add_trace(
                go.Scatter(
                    x=x,
                    y=y_upper[i],
                    name=f"{col} upper bound",
                    fill=None,
                    mode="lines",
                    line=dict(color="darksalmon", width=1),
                ),
                row=i + 1,
                col=1,
            )

            # Lower bound
            fig.add_trace(
                go.Scatter(
                    x=x,
                    y=y_lower[i],
                    name=f"{col} lower bound",
                    fill="tonexty",
                    mode="lines",
                    line=dict(color="darksalmon", width=1),
                ),
                row=i + 1,
                col=1,
            )

            fig.add_trace(
                go.Scatter(
                    x=x,
                    y=y_stats[i],
                    textposition="top center",
                    name=col,
                    mode="lines+markers",
                    connectgaps=True,
                    marker={"color": colors[i]},
                ),
                row=i + 1,
                col=1,
            )

        # Layout
        fig.update_layout(
            {
                "showlegend": False,
                "xaxis": {"title": "Year"},
                "yaxis": {"title": "Percentage"},
                **{f"xaxis{i}": {"title": "Year"} for i in range(1, n_rows + 1)},
                **{f"yaxis{i}": {"title": "Percentage"} for i in range(1, n_rows + 1)},
            }
        )

        return fig

    def plot_h2h(self) -> go.Figure:
        """Plots winrate by opponent"""

        x, b1, b2, wr = (
            self.h2h.select(
                ["opponent_name", "matches_won", "matches_lost", 100 * pl.col("win_rate")]
            )
            .to_numpy()
            .T
        )

        fig = make_subplots(specs=[[{"secondary_y": True}]])

        fig.add_trace(
            go.Bar(
                x=x,
                y=b1,
                name="Matches Won",
                marker={"color": "seagreen"},
                text=b1,
                textposition="inside",
                textfont_size=8,
                opacity=0.8,
            ),
            secondary_y=False,
        )
        fig.add_trace(
            go.Bar(
                x=x,
                y=b2,
                name="Matches Lost",
                marker={"color": "indianred"},
                text=b2,
                textposition="inside",
                textfont_size=8,
                opacity=0.8,
            ),
            secondary_y=False,
        )

        fig.add_trace(
            go.Scatter(
                x=x,
                y=wr,
                name="Win Rate",
                line={"color": "midnightblue", "width": 2},
                mode="markers+text",
                text=[str(p) + "%" for p in np.round(wr.astype(float), 2)],
                textposition="top center",
                textfont_size=8,
            ),
            secondary_y=True,
        )

        fig.update_layout(
            barmode="stack",
            legend={
                "font": {"size": 10},
                "orientation": "h",
                "yanchor": "bottom",
                "y": 1.05,
                "xanchor": "right",
                "x": 1,
            },
            title={
                "text": "Win Rate with most played opponents",
                "y": 0.9,
                "x": 0.5,
                "xanchor": "center",
                "yanchor": "top",
            },
            xaxis={"type": "category", "title": "Opponent name"},
            yaxis={"range": [0, np.max(b1 + b2) + 15], "title": "Number of Matches"},
            yaxis2={"range": [0, 110], "title": "Win Rate (%)"},
        )

        return fig


# TODO: refactor plot_serve_return_stats & plot_under_pressure; same left fig
